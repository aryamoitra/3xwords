# -------------------------------------------------------------------------------

# CS50 Final Project: 3xWords
# Author: Arya Moitra

# Description:
# This script implements a PyQt5 application for simplifying the process of
# creating, editing, and deleting posts on a Jekyll-based website hosted on
# GitHub Pages. This version of the script is specifically meant to be used
# for the Shakespeare in Bengal project.

# Requirements:
# - Python 3.12.4 or higher
# - Dependencies are listed in the `requirements.txt` file. To install them,
# run: pip install -r requirements.txt

# Usage:
# Run this script using Python: python 3xwords.py

# License:
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# Qt Designer Notice:
# This script includes code generated by Qt Designer, a graphical tool for
# designing user interfaces as part of the Qt framework. The generated code,
# produced through piuic5, has been combined with custom Python code. For
# more details, see <https://doc.qt.io/qt-5/qtdesigner-manual.html>.

# PyQt5 Notice:
# This project uses PyQt5, which is licensed under the GNU GPL v3. For more
# details, see <https://www.riverbankcomputing.com/software/pyqt/intro>.

# -------------------------------------------------------------------------------



import json
import os
import re

from git import Repo, GitCommandError
from PyQt5 import QtCore, QtGui, QtWidgets
import yaml

# Set default categories
category_lists = {
    "Performances": ["Performance Interviews", "Ephemera", "Video", "Reviews",],
    "Pedagogy": ["Pedagogy Interviews", "Notes",],
    "Exhibit": ["Videos", "Images", "Books and Essays", "Audio",],
    "Others": ["Student Productions", "Press",],
}


def get_repo_data(data_key):
    """Get data about the repository from repo.json"""
    result = None
    try:
        with open("repo.json", "r") as file:
            repo_data = json.load(file)
            result = repo_data[data_key]
            if result is None:
                raise KeyError(f"Key '{data_key}' not found in repo.json")
    except FileNotFoundError:
        setup = SetupWindow()
        information_message = "Please provide proper information about the repository."
        response = QtWidgets.QMessageBox.information(setup, "Information", information_message, QtWidgets.QMessageBox.Cancel | QtWidgets.QMessageBox.Ok, QtWidgets.QMessageBox.Ok)
        if response == QtWidgets.QMessageBox.Cancel:
            warning_message = "Cannot proceed without the necessary information. Close app?"
            final_response = QtWidgets.QMessageBox.warning(setup, "Information", warning_message, QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
            if final_response == QtWidgets.QMessageBox.Yes:
                sys.exit()
        setup.exec_()
    except (json.JSONDecodeError, KeyError) as error:
        error_message = f"Error: {error}\n\nPlease provide proper information about the repository."
        response = QtWidgets.QMessageBox.critical(setup, "Information", error_message, QtWidgets.QMessageBox.Cancel | QtWidgets.QMessageBox.Ok, QtWidgets.QMessageBox.Ok)
        if response == QtWidgets.QMessageBox.Cancel:
            warning_message = "Cannot proceed without the necessary information. Close app?"
            final_response = QtWidgets.QMessageBox.warning(setup, "Information", warning_message, QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
            if final_response == QtWidgets.QMessageBox.Yes:
                sys.exit()
        setup = SetupWindow()
        setup.exec_()          
    return result


class SetupWindow(QtWidgets.QDialog):
    def __init__(self):
        super().__init__()

        # Setup window
        self.setObjectName("setupWindow")
        self.setWindowModality(QtCore.Qt.ApplicationModal)
        self.resize(800, 170)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        self.setSizePolicy(sizePolicy)
        self.setMinimumSize(QtCore.QSize(800, 170))
        self.setMaximumSize(QtCore.QSize(800, 170))

        self.gridLayout = QtWidgets.QGridLayout(self)
        self.gridLayout.setObjectName("gridLayout")

        # Labels and Line Edits
        self.repoNameLabel = QtWidgets.QLabel(self)
        self.repoNameLabel.setObjectName("repoNameLabel")
        self.gridLayout.addWidget(self.repoNameLabel, 2, 0)
        self.repoLinkLabel = QtWidgets.QLabel(self)
        self.repoLinkLabel.setObjectName("repoLinkLabel")
        self.gridLayout.addWidget(self.repoLinkLabel, 0, 0)
        self.repoNameLineEdit = QtWidgets.QLineEdit(self)
        self.repoNameLineEdit.setObjectName("repoNameLineEdit")
        self.gridLayout.addWidget(self.repoNameLineEdit, 3, 0)
        self.repoLinkLineEdit = QtWidgets.QLineEdit(self)
        self.repoLinkLineEdit.setObjectName("repoLinkLineEdit")
        self.gridLayout.addWidget(self.repoLinkLineEdit, 1, 0)

        # Buttons and Vertical Spacer
        self.buttonBox = QtWidgets.QDialogButtonBox(self)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 5, 0)
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem, 4, 0)

        self.retranslateUi()

        # Set current repository link and name in the appropriate fields
        if os.path.exists("repo.json"):
            repo_link = get_repo_data("link")
            repo_dir_name = get_repo_data("name")
            self.repoLinkLineEdit.setText(repo_link)
            self.repoNameLineEdit.setText(repo_dir_name)
        
        # Deal with user response
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)


    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate("setupWindow", "Setup Window"))
        self.repoNameLabel.setText(_translate("setupWindow", "Repository Name"))
        self.repoLinkLabel.setText(_translate("setupWindow", "Repository Web URL"))

    def accept(self):
        """Handle response when user presses "OK" in the setup window"""
        repo_link = self.repoLinkLineEdit.text().strip()
        repo_dir_name = self.repoNameLineEdit.text().strip()
        repo_dir_path = f"../{repo_dir_name}/"
        if repo_link and repo_dir_name:
            repo_data = {
                "link": repo_link,
                "name": repo_dir_name
            }
            repo_json_object = json.dumps(repo_data, indent=4)
            with open("repo.json", "w") as file:
                file.write(repo_json_object)

            # Try to clone or pull the repository
            app = QtWidgets.QApplication.instance()
            main_window = [w for w in app.topLevelWidgets() if w.windowTitle() == "3xWords"]
            if main_window:
                try:
                    main_window.clone_or_pull(repo_link, repo_dir_path)
                except AttributeError:
                    pass
                super().accept()
        else:
            warning_message = "You must provide a valid repository link/name."
            QtWidgets.QMessageBox.warning(self, "W", warning_message, QtWidgets.QMessageBox.Ok)

    
    def reject(self):
        """Handle response when user presses "OK" in the setup window"""
        super().reject()


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):

        # Main window
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1000, 800)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        MainWindow.setMinimumSize(QtCore.QSize(1000, 800))

        # Central widget and vertical layout
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")

        # Author label
        self.author = QtWidgets.QLabel(self.centralwidget)
        self.author.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.author.setObjectName("author")
        self.verticalLayout.addWidget(self.author)

        # Tab widget
        self.tabWidget = QtWidgets.QTabWidget(self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tabWidget.sizePolicy().hasHeightForWidth())
        self.tabWidget.setSizePolicy(sizePolicy)
        self.tabWidget.setMinimumSize(QtCore.QSize(800, 600))
        self.tabWidget.setObjectName("tabWidget")

        # Post creation tab
        self.create = QtWidgets.QWidget()
        self.create.setObjectName("create")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.create)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.titleCreationLabel = QtWidgets.QLabel(self.create)
        self.titleCreationLabel.setObjectName("titleCreationLabel")
        self.gridLayout_4.addWidget(self.titleCreationLabel, 0, 0, 1, 1)
        self.dateCreationLabel = QtWidgets.QLabel(self.create)
        self.dateCreationLabel.setObjectName("dateCreationLabel")
        self.gridLayout_4.addWidget(self.dateCreationLabel, 0, 1, 1, 1)
        self.titleCreationLineEdit = QtWidgets.QLineEdit(self.create)
        self.titleCreationLineEdit.setObjectName("titleCreationLineEdit")
        self.gridLayout_4.addWidget(self.titleCreationLineEdit, 1, 0, 1, 1)
        self.dateCreationEdit = QtWidgets.QDateEdit(self.create)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dateCreationEdit.sizePolicy().hasHeightForWidth())
        self.dateCreationEdit.setSizePolicy(sizePolicy)
        self.dateCreationEdit.setObjectName("dateCreationEdit")
        self.gridLayout_4.addWidget(self.dateCreationEdit, 1, 1, 1, 1)
        self.dateCreationEdit.setDate(QtCore.QDate.currentDate())
        self.dateCreationEdit.setDisplayFormat("dd/MM/yyyy")
        self.tagsCreationLabel = QtWidgets.QLabel(self.create)
        self.tagsCreationLabel.setObjectName("tagsCreationLabel")
        self.gridLayout_4.addWidget(self.tagsCreationLabel, 2, 0, 1, 1)
        self.tagsCreationLineEdit = QtWidgets.QLineEdit(self.create)
        self.tagsCreationLineEdit.setObjectName("tagsCreationLineEdit")
        self.gridLayout_4.addWidget(self.tagsCreationLineEdit, 3, 0, 1, 2)
        self.categoryCreationLabel = QtWidgets.QLabel(self.create)
        self.categoryCreationLabel.setObjectName("categoryCreationLabel")
        self.gridLayout_4.addWidget(self.categoryCreationLabel, 4, 0, 1, 1)
        self.categoryCreationComboBox = QtWidgets.QComboBox(self.create)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.categoryCreationComboBox.sizePolicy().hasHeightForWidth())
        self.categoryCreationComboBox.setSizePolicy(sizePolicy)
        self.categoryCreationComboBox.setObjectName("categoryCreationComboBox")
        self.gridLayout_4.addWidget(self.categoryCreationComboBox, 5, 0, 1, 2)
        self.contentCreationLabel = QtWidgets.QLabel(self.create)
        self.contentCreationLabel.setObjectName("contentCreationLabel")
        self.gridLayout_4.addWidget(self.contentCreationLabel, 6, 0, 1, 1)
        self.contentCreationPlainTextEdit = QtWidgets.QPlainTextEdit(self.create)
        self.contentCreationPlainTextEdit.setPlaceholderText("")
        self.contentCreationPlainTextEdit.setObjectName("contentCreationPlainTextEdit")
        self.gridLayout_4.addWidget(self.contentCreationPlainTextEdit, 7, 0, 1, 2)
        self.creationQuote = QtWidgets.QLabel(self.create)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.creationQuote.sizePolicy().hasHeightForWidth())
        self.creationQuote.setSizePolicy(sizePolicy)
        self.creationQuote.setMinimumSize(QtCore.QSize(460, 150))
        self.creationQuote.setWordWrap(True)
        self.creationQuote.setObjectName("creationQuote")
        self.gridLayout_4.addWidget(self.creationQuote, 8, 0, 1, 1)
        self.publishButton = QtWidgets.QPushButton(self.create)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.publishButton.sizePolicy().hasHeightForWidth())
        self.publishButton.setSizePolicy(sizePolicy)
        self.publishButton.setObjectName("publishButton")
        self.gridLayout_4.addWidget(self.publishButton, 8, 1, 1, 1)

        # Post editing tab
        self.tabWidget.addTab(self.create, "")
        self.edit = QtWidgets.QWidget()
        self.edit.setEnabled(True)
        self.edit.setObjectName("edit")
        self.gridLayout = QtWidgets.QGridLayout(self.edit)
        self.gridLayout.setObjectName("gridLayout")
        self.selectPostEditingLabel = QtWidgets.QLabel(self.edit)
        self.selectPostEditingLabel.setObjectName("selectPostEditingLabel")
        self.gridLayout.addWidget(self.selectPostEditingLabel, 0, 0, 1, 1)
        self.selectPostEditingLineEdit = QtWidgets.QLineEdit(self.edit)
        self.selectPostEditingLineEdit.setObjectName("selectPostEditingLineEdit")
        self.gridLayout.addWidget(self.selectPostEditingLineEdit, 1, 0, 1, 2)
        self.titleEditingLabel = QtWidgets.QLabel(self.edit)
        self.titleEditingLabel.setObjectName("titleEditingLabel")
        self.gridLayout.addWidget(self.titleEditingLabel, 2, 0, 1, 1)
        self.dateEditingLabel = QtWidgets.QLabel(self.edit)
        self.dateEditingLabel.setObjectName("dateEditingLabel")
        self.gridLayout.addWidget(self.dateEditingLabel, 2, 1, 1, 1)
        self.titleEditingLineEdit = QtWidgets.QLineEdit(self.edit)
        self.titleEditingLineEdit.setObjectName("titleEditingLineEdit")
        self.gridLayout.addWidget(self.titleEditingLineEdit, 3, 0, 1, 1)
        self.dateEditingEdit = QtWidgets.QDateEdit(self.edit)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dateEditingEdit.sizePolicy().hasHeightForWidth())
        self.dateEditingEdit.setSizePolicy(sizePolicy)
        self.dateEditingEdit.setObjectName("dateEditingEdit")
        self.gridLayout.addWidget(self.dateEditingEdit, 3, 1, 1, 1)
        self.dateEditingEdit.setDate(QtCore.QDate.currentDate())
        self.dateEditingEdit.setDisplayFormat("dd/MM/yyyy")
        self.tagsEditingLabel = QtWidgets.QLabel(self.edit)
        self.tagsEditingLabel.setObjectName("tagsEditingLabel")
        self.gridLayout.addWidget(self.tagsEditingLabel, 4, 0, 1, 1)
        self.tagsEditingLineEdit = QtWidgets.QLineEdit(self.edit)
        self.tagsEditingLineEdit.setObjectName("tagsEditingLineEdit")
        self.gridLayout.addWidget(self.tagsEditingLineEdit, 5, 0, 1, 2)
        self.categoryEditingLabel = QtWidgets.QLabel(self.edit)
        self.categoryEditingLabel.setObjectName("categoryEditingLabel")
        self.gridLayout.addWidget(self.categoryEditingLabel, 6, 0, 1, 1)
        self.categoryEditingComboBox = QtWidgets.QComboBox(self.edit)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.categoryEditingComboBox.sizePolicy().hasHeightForWidth())
        self.categoryEditingComboBox.setSizePolicy(sizePolicy)
        self.categoryEditingComboBox.setObjectName("categoryEditingComboBox")
        self.gridLayout.addWidget(self.categoryEditingComboBox, 7, 0, 1, 2)
        self.contentEditingLabel = QtWidgets.QLabel(self.edit)
        self.contentEditingLabel.setObjectName("contentEditingLabel")
        self.gridLayout.addWidget(self.contentEditingLabel, 8, 0, 1, 1)
        self.contentEditingPlainTextEdit = QtWidgets.QPlainTextEdit(self.edit)
        self.contentEditingPlainTextEdit.setObjectName("contentEditingPlainTextEdit")
        self.gridLayout.addWidget(self.contentEditingPlainTextEdit, 9, 0, 1, 2)
        self.editingQuote = QtWidgets.QLabel(self.edit)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.editingQuote.sizePolicy().hasHeightForWidth())
        self.editingQuote.setSizePolicy(sizePolicy)
        self.editingQuote.setMinimumSize(QtCore.QSize(460, 150))
        self.editingQuote.setWordWrap(True)
        self.editingQuote.setObjectName("editingQuote")
        self.gridLayout.addWidget(self.editingQuote, 10, 0, 1, 1)
        self.editButton = QtWidgets.QPushButton(self.edit)
        self.editButton.setObjectName("editButton")
        self.gridLayout.addWidget(self.editButton, 10, 1, 1, 1)

        # Post deletion tab
        self.tabWidget.addTab(self.edit, "")
        self.delete = QtWidgets.QWidget()
        self.delete.setObjectName("delete")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.delete)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.selectPostDeletionLabel = QtWidgets.QLabel(self.delete)
        self.selectPostDeletionLabel.setObjectName("selectPostDeletionLabel")
        self.gridLayout_5.addWidget(self.selectPostDeletionLabel, 0, 0, 1, 1)
        self.selectPostDeletionLineEdit = QtWidgets.QLineEdit(self.delete)
        self.selectPostDeletionLineEdit.setObjectName("selectPostDeletionLineEdit")
        self.gridLayout_5.addWidget(self.selectPostDeletionLineEdit, 1, 0, 1, 2)
        self.deleteButton = QtWidgets.QPushButton(self.delete)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.deleteButton.sizePolicy().hasHeightForWidth())
        self.deleteButton.setSizePolicy(sizePolicy)
        self.deleteButton.setObjectName("deleteButton")
        self.gridLayout_5.addWidget(self.deleteButton, 2, 1, 1, 1)
        self.deletionQuote = QtWidgets.QLabel(self.delete)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.deletionQuote.sizePolicy().hasHeightForWidth())
        self.deletionQuote.setSizePolicy(sizePolicy)
        self.deletionQuote.setMinimumSize(QtCore.QSize(460, 150))
        self.deletionQuote.setAlignment(QtCore.Qt.AlignCenter)
        self.deletionQuote.setWordWrap(True)
        self.deletionQuote.setObjectName("deletionQuote")
        self.gridLayout_5.addWidget(self.deletionQuote, 3, 0, 1, 2)
        spacerItem = QtWidgets.QSpacerItem(947, 358, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_5.addItem(spacerItem, 4, 0, 1, 2)
        self.tabWidget.addTab(self.delete, "")

        self.verticalLayout.addWidget(self.tabWidget)

        # Instructions label
        self.instructions = QtWidgets.QLabel(self.centralwidget)
        self.instructions.setObjectName("instructions")
        self.verticalLayout.addWidget(self.instructions)

        MainWindow.setCentralWidget(self.centralwidget)

        # Menu bar and status bar
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1000, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        # Attempt to clone the repository twice in the case of a GitCommandError related to repository None not existing and close the app on third attempt
        # Close the app immediately if there are other errors
        repo_data_success = False
        max_attempts = 2
        current_attempt = 0
        while current_attempt < max_attempts:
            try:

                # Clone the repository for the first time or, if it already exists, pull for the latest changes
                repo_link = get_repo_data("link")
                repo_dir_name = get_repo_data("name")
                repo_dir_path = f"../{repo_dir_name}/"
                self.repo = self.clone_or_pull(repo_link, repo_dir_path)
                repo_data_success = True
                break

            except GitCommandError as git_error:
                if "repository 'None' does not exist" in git_error.stderr:
                    print(git_error)
                    current_attempt += 1
                    continue
                else:
                    QtWidgets.QMessageBox.critical(self.centralwidget, "Error", str(git_error), QtWidgets.QMessageBox.Ok)
                    break
            
            except Exception as error:
                QtWidgets.QMessageBox.critical(self.centralwidget, "Error", str(error), QtWidgets.QMessageBox.Ok)
                break
        if not repo_data_success:
            error_message = "Failed to load repository data. Closing app..."
            QtWidgets.QMessageBox.critical(self.centralwidget, "Error", error_message, QtWidgets.QMessageBox.Ok)
            sys.exit()

        # Create a way to open the setup window
        shortcut = QtWidgets.QShortcut(QtGui.QKeySequence("Ctrl+S"), self.centralwidget)
        shortcut.activated.connect(lambda: SetupWindow().exec_())

        # Set maximum character limit for title fields
        self.titleCreationLineEdit.setMaxLength(190)
        self.titleEditingLineEdit.setMaxLength(190)

        # Add categories
        self.add_categories(self.categoryCreationComboBox, category_lists)
        self.add_categories(self.categoryEditingComboBox, category_lists)

        # Set up completer and dynamically load file names
        posts_directory = f"../{repo_dir_name}/_posts/"
        try:
            self.completer = QtWidgets.QCompleter()
            self.completer.setCaseSensitivity(0)
            self.watcher = QtCore.QFileSystemWatcher()
            self.watcher.addPath(posts_directory)
            self.watcher.directoryChanged.connect(lambda path: self.directory_changed(path, self.completer))
            self.load_file_names(posts_directory, self.completer)
            self.selectPostEditingLineEdit.setCompleter(self.completer)
            self.selectPostDeletionLineEdit.setCompleter(self.completer)
        except Exception as error:
            QtWidgets.QMessageBox.critical(self.centralwidget, "Error", str(error), QtWidgets.QMessageBox.Ok)

        # Add functionality to the publish button
        self.publishButton.clicked.connect(lambda: self.publish(self.titleCreationLineEdit, self.dateCreationEdit, self.tagsCreationLineEdit, self.categoryCreationComboBox, category_lists, self.contentCreationPlainTextEdit, posts_directory))

        # Load file for editing when the return/enter key is pressed in the "Select Post" box in the edit tab
        self.selectPostEditingLineEdit.returnPressed.connect(lambda: self.load_edit_file(self.selectPostEditingLineEdit, self.titleEditingLineEdit, self.tagsEditingLineEdit, self.categoryEditingComboBox, self.contentEditingPlainTextEdit, posts_directory))

        # Add functionality to the edit button
        self.editButton.clicked.connect(lambda: self.publish(self.titleEditingLineEdit, self.dateEditingEdit, self.tagsEditingLineEdit, self.categoryEditingComboBox, category_lists, self.contentEditingPlainTextEdit, posts_directory, self.selectPostEditingLineEdit, is_edit=True))

        # Add functionality to the delete button
        self.deleteButton.clicked.connect(lambda: self.delete_file(f"{posts_directory}{self.selectPostDeletionLineEdit.text()}"))


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "3xWords"))
        self.author.setText(_translate("MainWindow", "Made by Arya Moitra"))

        self.titleCreationLabel.setText(_translate("MainWindow", "Title"))
        self.dateCreationLabel.setText(_translate("MainWindow", "Date"))
        self.tagsCreationLabel.setText(_translate("MainWindow", "Tags"))
        self.tagsCreationLineEdit.setPlaceholderText(_translate("MainWindow", "Enter comma-separated values (e.g., interview, play, adaptation)."))
        self.categoryCreationLabel.setText(_translate("MainWindow", "Category"))
        self.contentCreationLabel.setText(_translate("MainWindow", "Content"))
        self.creationQuote.setText(_translate("MainWindow", "So long as men can breathe, or eyes can see, / So long lives this, and this gives life to thee. (Sonnet 18, lines 13-14)"))
        self.publishButton.setText(_translate("MainWindow", "Publish"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.create), _translate("MainWindow", "Create"))

        self.selectPostEditingLabel.setText(_translate("MainWindow", "Select Post"))
        self.selectPostEditingLineEdit.setPlaceholderText(_translate("MainWindow", "Type the name of the file and press Enter."))
        self.titleEditingLabel.setText(_translate("MainWindow", "Title"))
        self.dateEditingLabel.setText(_translate("MainWindow", "Date"))
        self.tagsEditingLabel.setText(_translate("MainWindow", "Tags"))
        self.tagsEditingLineEdit.setPlaceholderText(_translate("MainWindow", "Enter comma-separated values (e.g., interview, play, adaptation)."))
        self.categoryEditingLabel.setText(_translate("MainWindow", "Category"))
        self.contentEditingLabel.setText(_translate("MainWindow", "Content"))
        self.editingQuote.setText(_translate("MainWindow", "Our doubts are traitors / And make us lose the good we oft might win / By fearing to attempt. (Measure for Measure, Act 1, Scene 4) "))
        self.editButton.setText(_translate("MainWindow", "Edit"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.edit), _translate("MainWindow", "Edit"))

        self.selectPostDeletionLabel.setText(_translate("MainWindow", "Select Post"))
        self.selectPostDeletionLineEdit.setPlaceholderText(_translate("MainWindow", "Type the name of the file."))
        self.deleteButton.setText(_translate("MainWindow", "Delete"))
        self.deletionQuote.setText(_translate("MainWindow", "Parting is such sweet sorrow, / That I shall say good night till it be morrow. (Romeo and Juliet, Act 2, Scene 2)"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.delete), _translate("MainWindow", "Delete"))

        self.instructions.setText(_translate("MainWindow", "Press Ctrl+S (Cmd+S on macOS) to open the setup window."))


    def clone_or_pull(self, repo_link, local_repo_path):
        """Clone repository if it does not exists or pull for latest changes from the main branch if it does"""
        abs_local_repo_path = os.path.abspath(local_repo_path)
        if not os.path.exists(abs_local_repo_path):
            self.repo = Repo.clone_from(repo_link, local_repo_path)

            # Send confirmation if the cloned repository exists in the specified directory
            if os.path.exists(abs_local_repo_path):
                info = f"As {abs_local_repo_path} did not exist, the repository has been cloned to your local machine."
                QtWidgets.QMessageBox.information(self.centralwidget, "Information", info, QtWidgets.QMessageBox.Ok)

        else:
            self.repo = Repo(local_repo_path)
            self.repo.remotes.origin.pull("main")
            print("pull")
        return self.repo


    def create_branch(self, name):
        """Create a new branch and set it as the current branch"""

        #  Truncate the branch name to 90 characters if it is longer than that and add dots to indicate
        if len(name) > 90:
            name = name[:90] + "-TRUNC"

        # Check whether the branch name is unique and, if not, assign a number at the end to make it unique
        existing_branches = []
        for branch in self.repo.branches:
            existing_branches.append(branch.name)
        unique_name = name
        number = 1
        while True:
            if unique_name not in existing_branches:
                break
            unique_name = f"{name}-{str(number)}"
            number += 1

        # Create a branch with the unique name and switch to it
        new_branch = self.repo.create_head(unique_name)
        self.repo.head.reference = new_branch

        return new_branch
    

    def merge(self, new_branch_name, is_edit=False, is_delete=False):
        """Merge a branch with the main branch, return True if it succeeds, return False if it does not"""

        # Switch to the main branch
        self.repo.heads.main.checkout()

        try:
            # Merge the new branch into main
            self.repo.git.merge(new_branch_name)
            merge_success_message = "Merge completed successfully!"
            QtWidgets.QMessageBox.information(self.centralwidget, "Information", merge_success_message, QtWidgets.QMessageBox.Ok)
            return True

        except GitCommandError:

            # If merge conflict occurs while editing, and if the user agrees, delete the new branch and pull the newest version of the file from the main branch
            if is_edit:
                error_message = "Merge failed! The file may have been modified by someone else. Do you want to load the latest version of the file? (Warning: The changes made by you will be discarded if you proceed.)"
                response = QtWidgets.QMessageBox.critical(self.centralwidget, "Error", error_message, QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
                if response == QtWidgets.QMessageBox.Yes:
                    self.repo.delete_head(new_branch_name, force=True)
                    repo_dir_name = get_repo_data("name")
                    posts_directory = f"../{repo_dir_name}/_posts/"
                    self.load_edit_file(self.selectPostEditingLineEdit, self.titleEditingLineEdit, self.tagsEditingLineEdit, self.categoryEditingComboBox, self.contentEditingPlainTextEdit, posts_directory)

            
            else:

                # If the conflict occurs during deleting a file, urge the user to try again
                if is_delete:
                    error_message = "Merge failed! Please try deleting the file again."
            
                # If the conflict occurs during publishing a new post, direct the user to the edit/delete tab, 
                else:
                    error_message = "Merge failed! A different file with the same name may have been created by someone else. Please go to the edit tab to modify the file or, alternatively, remove it using the delete tab."

                # In either case (conflict during deletion/publishing), pull the latest version of the main branch and delete the new branch
                QtWidgets.QMessageBox.critical(self.centralwidget, "Error", error_message, QtWidgets.QMessageBox.Ok)
                repo_link = get_repo_data("link")
                repo_dir_name = get_repo_data("name")
                repo_dir_path = f"../{repo_dir_name}/"
                self.repo = self.clone_or_pull(repo_link, repo_dir_path)
                self.repo.delete_head(new_branch_name, force=True)

            return False


    def add_categories(self, combo_box, category_lists_dict):
        """Add section headers (names of category lists) and items (elements in category lists) from a dictionary of category lists to the QComboBox."""

        # Clear existing items
        combo_box.clear()

        # Add all section headers, items, and separators
        header_index = 0
        for category_list_name, category_list in category_lists_dict.items():
            combo_box.addItem(category_list_name)
            combo_box.model().item(header_index).setEnabled(False) # Disable section header
            combo_box.addItems(category_list)
            separator_index = header_index + len(category_list) + 1
            combo_box.insertSeparator(separator_index)
            header_index = separator_index + 1
        combo_box.setCurrentIndex(1)


    def load_file_names(self, posts_dir, completer):
        """Load file names for QCompleter"""

        # Get the list of files in the "_posts" directory
        file_names = []
        for file in os.listdir(posts_dir):
            if os.path.isfile(os.path.join(posts_dir, file)):
                file_names.append(file)

        # Create and set the completer model
        model = QtCore.QStringListModel(file_names)
        completer.setModel(model)


    def publish(self, title_line_edit, date_edit, tags_line_edit, category_combo_box, category_lists_dict, content_plain_text_edit, directory, select_post_edit=None, is_edit=False):
        """Create a markdown file with the data in the 'create' tab and publish the post"""
        try:
            # Clone/pull repository for the latest changes
            repo_link = get_repo_data("link")
            repo_dir_name = get_repo_data("name")
            repo_dir_path = f"../{repo_dir_name}/"
            self.repo = self.clone_or_pull(repo_link, repo_dir_path)

            # If the file is being edited, check whether it is a valid markdown file
            if is_edit and select_post_edit:
                old_file_name = select_post_edit.text()
                if not old_file_name.endswith(".md") and not old_file_name.endswith(".markdown"):
                    raise ValueError(f"Error: {old_file_name} is not a valid markdown file.")
                
            # If the file is being edited, ensure that the "Select Post" section is not null
            if is_edit and not select_post_edit:
                raise ValueError("Error: The post selection field cannot have a null value during editing.")

            # Store title, date, and tags in appropriate variables
            title = title_line_edit.text().strip()
            date = date_edit.date()
            if not date.isValid():
                raise ValueError("Error: Invalid date")
            year = date.year()
            month = date.month()
            day = date.day()
            tags = []
            unstripped_tags = tags_line_edit.text().split(",")
            for tag in unstripped_tags:
                if tag:
                    tags.append(tag.strip())

            # Store both section header (category_list_name) and items as categories
            categories = []
            chosen_item = str(category_combo_box.currentText()).lower()
            categories.append(chosen_item)
            for category_list_name, category_list in category_lists_dict.items():
                if category_list_name == "Others":
                    continue
                for item in category_list:
                    if item.lower() == chosen_item:
                        categories.insert(0, category_list_name.lower())
                        break

            # Store content
            content = content_plain_text_edit.toPlainText().rstrip()

            # Stop if title, date, categories, or content is empty
            if not title or not date or not categories or not content:
                raise ValueError("Error: At least one of the required fields is empty")

            # Combine the variables to create a post in markdown
            # WARNING: The edit_file() function depends on the date separator; be mindful of that while changing it
            # Current date separator: /
            markdown_post = f"""---
layout: post
title:  {title}
date: {day}/{month}/{year}
tags: {tags}
categories: {categories}
---

{content}
"""
            # Save the markdown file in the "_posts" directory and confirm the completion of file creation/editing
            hyphenated_title = re.sub(r'\s+', '-', title.strip())
            new_file_name = f"{str(year)}-{str(month)}-{str(day)}-{hyphenated_title}.md"
            new_file_path = directory + new_file_name
            new_sanitized_file_name = self.sanitize_file_name(new_file_name, new_file_path)
            new_file_path = directory + new_sanitized_file_name
            if not self.posts_directory_exists(new_file_path):
                return
            if is_edit:
                try:
                    old_file_path = directory + old_file_name
                    os.remove(old_file_path)
                    with open(new_file_path, 'w') as file:
                        file.write(markdown_post)
                    if old_file_name != new_sanitized_file_name:
                        print(f"{old_file_name} has been successfully edited!\nNew file name with updated title and/or date: {new_sanitized_file_name}")
                        select_post_edit.setText(new_sanitized_file_name)
                    else:
                        print(f"{new_sanitized_file_name} has been successfully edited!")
                    if new_sanitized_file_name != new_file_name:
                            print(f"The file name has been truncated as it was too long. ({len(new_file_name)} characters including the length of the file extension)")
                except FileNotFoundError:
                    error_message = f"{old_file_name} could not be found. Please check if the file name in the \"Select Post\" field is valid."
                    QtWidgets.QMessageBox.critical(self.centralwidget, "Error", error_message, QtWidgets.QMessageBox.Ok)
            else:
                with open(new_file_path, 'w') as file:
                    file.write(markdown_post)
                print(f"{new_sanitized_file_name} has been successfully created!")

            # Create a new branch and commit changes to the branch
            new_branch = self.create_branch(new_sanitized_file_name)
            self.repo.git.add(A=True)
            if is_edit:
                action = "Edit post"
            else:
                action = "Add post"
            self.repo.index.commit(f"{action}: {new_sanitized_file_name}")
            self.repo.remotes.origin.push(new_branch)

            # Merge with the main branch and commit changes
            success = self.merge(new_branch.name, is_edit=is_edit)
            if success:
                self.repo.remotes.origin.push("main")

        except ValueError as error:
            QtWidgets.QMessageBox.critical(self.centralwidget, "Error", str(error), QtWidgets.QMessageBox.Ok)

    
    def load_edit_file(self, select_post_line_edit, title_line_edit, tags_line_edit, category_combo_box, content_plain_text_edit, directory):
        """Load file contents into the program for editing"""


        def extract_front_matter_and_content(file_contents):
            """ Extracts YAML front matter and the content from markdown content. """
            # Regular expression to match the front matter block
            front_matter_pattern = re.compile(r'^---\s*\n(.*?)\n---\s*\n(.*)', re.DOTALL | re.MULTILINE)
            match = front_matter_pattern.search(file_contents)
            
            if match:
                front_matter = match.group(1)
                content = match.group(2)
                return front_matter, content
            else:
                raise ValueError("The file does not contain proper YAML front matter")


        def parse_front_matter(front_matter):
            """ Parses YAML front matter and extracts relevant fields. """
            try:
                # Parse YAML front matter
                data = yaml.safe_load(front_matter)
                
                # Extract fields
                title = data.get('title', '')
                tags = data.get('tags', [])
                categories = data.get('categories', [])
                
                return title, tags, categories
            
            except yaml.YAMLError as error:
                print(f"Error parsing YAML: {error}")
                return None, None, None
            

        # Clone/pull repository for the latest changes
        repo_link = get_repo_data("link")
        repo_dir_name = get_repo_data("name")
        repo_dir_path = f"../{repo_dir_name}/"
        self.repo = self.clone_or_pull(repo_link, repo_dir_path)

        # Check whether the file exists and whether it is a valid markdown file
        file_name = select_post_line_edit.text()
        file_path = directory + file_name
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            print("Error: Enter a valid file name")
            return
        if not self.posts_directory_exists(file_path):
            return
        _, extension = os.path.splitext(file_name)
        if extension not in [".md", ".markdown"]:
            print("Error: This is not a markdown file")

        # Store the file contents in appropriate variables
        with open(file_path, 'r') as file:
                file_contents = file.read()
                front_matter, content = extract_front_matter_and_content(file_contents)
                if front_matter:
                    title, tags, categories = parse_front_matter(front_matter)

        # Warn the user if title, date, and/or categories is/are missing
        if not title or not categories:
            print("Error: The file does not contain title/categories, which are expected to be present in all posts\nProceed with caution as editing the file will force it to comply with the usual template, disregarding its original structure")

        # Display the title
        if title:
            title_line_edit.setText(title)

        # Format the tags for displaying
        tags_str = ""
        if tags:
            for tag in tags:
                if tag == tags[-1]:
                    tags_str += tag
                    break
                tags_str += tag + ", "

        # Display the tags
        tags_line_edit.setText(tags_str)

        # If multiple categories exist, store only the last one as the category combo box item to display in the category combo box
        if categories:
            if len(categories) > 1:
                category_combo_box_item = categories[-1]
            else:
                category_combo_box_item = categories[0]

        # Display the category item
        item_count = category_combo_box.count()
        for item_index in range(item_count):
            if category_combo_box_item == category_combo_box.itemText(item_index).lower():
                category_combo_box.setCurrentIndex(item_index)
                break

        # Display content body
        content_plain_text_edit.setPlainText(content)


    def delete_file(self, file_path):
        """Delete files in the "_posts" directory """

        # Handle errors
        if not os.path.exists(file_path) or not os.path.isfile(file_path):
            print("Error: Enter a valid file name")
            return
        if not self.posts_directory_exists(file_path):
            return
        
        # Get file name and delete file locally
        file_name = os.path.basename(file_path)
        os.remove(file_path)

        # Set the "Select Post" field to empty
        self.selectPostDeletionLineEdit.setText("")

        # Create a new branch and commit changes to the branch
        new_branch = self.create_branch(file_name)
        self.repo.git.add(A=True)
        self.repo.index.commit(f"Delete post: {file_name}")
        self.repo.remotes.origin.push(new_branch)

        # Merge with the main branch and commit changes
        success = self.merge(new_branch.name, is_delete=True)
        if success:
            self.repo.remotes.origin.push("main")


    def posts_directory_exists(self, file_path):
        """Check whether the _posts directory is valid"""
        directory_path = os.path.dirname(file_path)
        folder = os.path.basename(directory_path)
        if folder != "_posts":
            print(f"Error: Attempted to create/modify/delete a file in a folder named \"{folder}\"\nOnly the files in \"_posts\" can be managed")
            return False
        if not os.path.exists(directory_path):
            print("Error: The directory path does not exist\nCheck whether there is a folder named \"_posts\" in the local repository")
            return False
        return True
    

    def directory_changed(self, path, completer):
        """Called when the directory changes"""
        self.load_file_names(path, completer)


    def sanitize_file_name(self, file_name, file_path):
        """Sanitize a file name by removing or replacing forbidden characters and shortening length if needed"""

        # Remove forbidden characters
        forbidden_chars = r"[^\w_. -]"
        sanitized_file_name = re.sub(forbidden_chars, "", file_name)

        # Replace consecutive hyphens with a single hyphen
        consecutive_hyphens = r"-+"
        sanitized_file_name = re.sub(consecutive_hyphens, "-", sanitized_file_name)

        # Shorten the length of the file name
        max_path_len = 250
        min_file_name_len = 20
        abs_file_path = os.path.abspath(file_path)
        abs_file_path_len = len(abs_file_path)
        directory_path = os.path.dirname(abs_file_path)
        directory_path_len = len(directory_path)
        if (abs_file_path_len - directory_path_len) >= min_file_name_len:
            while (directory_path_len + len(sanitized_file_name)) > (max_path_len - len(".md")):
                sanitized_file_name = sanitized_file_name[:-1]

        # Add proper extension to the truncated name if it does not have one
        if not sanitized_file_name.endswith(".md") and not sanitized_file_name.endswith(".markdown"):
            sanitized_file_name += ".md"

        return sanitized_file_name


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
